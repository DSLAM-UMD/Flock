name: CI

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]

env:
  CARGO_TERM_COLOR: always

  # LAMBDA_NAME: hello step_1 step_2 gen_data
  # AWS_LAMBDA_ROLE: ${{ secrets.AWS_LAMBDA_ROLE }}

jobs:
  test:
    # if: github.ref != 'refs/heads/master'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache Cargo
        uses: actions/cache@v2
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: nightly
          override: true
          components: rustfmt, clippy
      - name: update umd-arrow
        run: |
          cargo update --package arrow
      - name: build and tests
        run: |
          cargo build -j8
          cargo test

  coverage:
    name: Coverage
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Cache Cargo
        uses: actions/cache@v2
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          # this key is not equal because coverage uses different compilation flags.
          key: ${{ runner.os }}-cargo-target-coverage-cache
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: nightly
          override: true
          components: rustfmt, clippy
      - name: update umd-arrow
        run: |
          cargo update --package arrow
          cargo update --package datafusion
      - name: Run cargo-tarpaulin
        uses: actions-rs/tarpaulin@v0.1
        with:
          version: latest
          args: '-- --test-threads 8'
      - name: Upload to codecov.io
        uses: codecov/codecov-action@v1.0.2
        with:
          token: ${{secrets.CODECOV_TOKEN}}
      - name: Archive code coverage results
        uses: actions/upload-artifact@v1
        with:
          name: code-coverage-report
          path: cobertura.xml

  # deploy on pushes to master branch
  # assumes aws credentials (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY)
  # are configured in travis settings
  # see https://serverless.com/framework/docs/providers/aws/guide/credentials/
  # for more information
  # deploy:
  #   if: github.ref == 'refs/heads/master'
  #   runs-on: ubuntu-latest
  #   strategy:
  #     matrix:
  #       target:
  #         - x86_64-unknown-linux-gnu
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v2
  #     - name: Cache cargo and xargo
  #       uses: actions/cache@v2
  #       with:
  #         path: |
  #           ~/.cargo/registry
  #           ~/.cargo/git
  #           ~/.xargo
  #           target
  #         key: ${{ runner.os }}-cargo-squirtle-${{ hashFiles('**/Cargo.lock') }}
  #     - name: Install nightly
  #       uses: actions-rs/toolchain@v1
  #       with:
  #         toolchain: nightly
  #         override: true
  #       if: steps.cache.outputs.cache-hit != 'true'
  #     - name: Install xargo
  #       run: |
  #         rustup override set nightly
  #         rustup component add rust-src
  #         cargo install xargo
  #       if: steps.cache.outputs.cache-hit != 'true'
  #     - name: Build
  #       run: |
  #         rustup override set nightly
  #         xargo update --package arrow
  #         xargo build --target ${{ matrix.target }} --release
  #     - name: Configure AWS credentials
  #       uses: aws-actions/configure-aws-credentials@v1
  #       with:
  #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         aws-region: us-east-1
  #     - name: AWS lambda package
  #       run: |
  #         for f in $LAMBDA_NAME; do
  #           mv ./target/x86_64-unknown-linux-gnu/release/$f ./bootstrap;
  #           strip --strip-all ./bootstrap;
  #           zip -j $f.zip ./bootstrap;
  #           GET_FUNCTION_NAME=$(aws lambda list-functions --query \
  #             "Functions[?FunctionName=='${f}'].FunctionName[]" --output text);
  #           echo "${GET_FUNCTION_NAME}";
  #           if [ "${GET_FUNCTION_NAME}" == "${f}" ]; then
  #             aws lambda update-function-code --function-name $f --zip-file fileb://./$f.zip;
  #             echo "Congratulations! You've successfully upgraded Squirtle.";
  #           else
  #             aws lambda create-function --function-name $f \
  #               --runtime provided.al2 \
  #               --role $AWS_LAMBDA_ROLE \
  #               --handler doesnt.matter \
  #               --zip-file fileb://./$f.zip \
  #               --environment Variables={RUST_BACKTRACE=1} \
  #               --tracing-config Mode=Active;
  #             echo "Congratulations! You've successfully deployed Squirtle.";
  #           fi
  #         done
